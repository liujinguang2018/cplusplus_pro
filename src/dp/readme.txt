模式的基本概念也可以看作是设计的基本概念：即增加一个抽象层。无论什么时
候，当你想把某些东西抽象出来的时候，实际上你是在分离特定的细节，这么做的一
个有说服力的动机就是把变化的东西从那些不变的东西里分离出来。这个问题的另一
种说法是，当你发现程序的某一部分由于某种原因有可能会变化的话，你会希望这些
变化不会传播给程序代码的其它部分。这么做不但使程序更容易维护，而且它通常使
程序更容易理解（这将降低成本）。

1. 创建型(creational)模式
    如何创建一个对象。这通常包括分离对象创建的细节，这样你的代码就不依赖于对象
    的类型，而且当加入新的类型的对象时也不必改代码。
1.1 Factory模式
    Factory模式的两个重要的功能：
    1）定义创建对象的接口，封装了对象的创建
    2）使得具体化类的工作延迟到了子类中
    局限于创建一类类（有共同基类）

1.2 Abstract Factory模式
    用于创建一组相关或者相互依赖的对象，关键就是将一组对象的创建封装到一个
    用于创建对象的类（ConcreteFactory）中。
    AbstractFactory模式和Factory模式的区别是初学（使用）设计模式时候的一个容易
    引起困惑的地方。实际上，AbstractFactory模式是为创建一组（有多类）相关或依赖
    的对象提供创建接口，而Factory模式正如我在相应的文档中分析的是为一类对象提供
    创建接口或延迟对象的创建到子类中实现。并且可以看到，AbstractFactory模式通
    常都是使用Factory模式实现（ConcreteFactory1）。
1.3 Singleton模式
    Singleton模式经常和Factory(AbstractFactory)模式一起使用，因为系统中工厂对象
    一般来说只有一个。
1.4 Builder模式
    当我们要创建的对象很复杂的时候(通常是由很多其它的对象组合而成)，我们要把复杂
    对象的创建过程和这个对象的表示分离开来，这样做的好处就是通过一步步的进行复杂
    对象的构建，由于每一步的构造过程中可以引入参数，使得经过相同的步骤创建最后
    得到的对象的展示不一样。
    Builder模式与AbstractFactory模式在功能上很相似，因为都是用来创建大的复杂的
    对象，它们的区别是：Builder模式强调的是一步步创建对象，并通过相同的创建过程
    可以获得不同的结果对象，一般来说Builder模式的对象不是直接返回的。而在AbstractFactory
    模式中对象是直接返回的，AbstractFactory模式强调的是为创建多个相互依赖的对象
    提供一个统一的接口。
1.5 ProtoType模式
    ProtoType模式提供了一个通过已存在对象进行新对象创建的接口clone, clone()
    接口实现和具体的实现语言相关，在C++中使用copy构造函数实现.

    ProtoType模式通过复制原型(ProtoType)而获得新对象的创建的功能，这里ProtoType本身
    就是"对象工厂"，实际上，prototype模式、builder模式、AbstractFactory模式都是
    通过一个类（对象实例）来专门负责对象的创建工作（工厂对象），它们之间的区别：
    Builder模式重在复杂对象的一步步创建（并不直接返回对象）
    AbstractFactory模式重在产生多个相互依赖类的对象
    ProtoType模式重在从自身复制自己创建新类
    


2. 结构型(structural)模式
    设计出满足某些工程里特定约束的对象。它的工作原理是这样的：一组对象与其它对象
    相关联，当系统发生变化的时候，这些对象之间的关联关系不变。
2.1 Bridge模式
    使用组合（委托）的方式将抽象和实现彻底地解耦，这样是抽象和实现可以分别独立变化

2.2 Adapter模式
    提供将一个类的接口转化为客户希望的接口，有2种实现方式：类模式和对象模式

2.3 Decorator模式
    提供了一种给类增加职责的方法，不是通过继承实现，而是通过组合


3. 行为型(Behavioral)模式
    指一个程序里处理一系列特定类型操作的对象。