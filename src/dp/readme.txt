模式的基本概念也可以看作是设计的基本概念：即增加一个抽象层。无论什么时
候，当你想把某些东西抽象出来的时候，实际上你是在分离特定的细节，这么做的一
个有说服力的动机就是把变化的东西从那些不变的东西里分离出来。这个问题的另一
种说法是，当你发现程序的某一部分由于某种原因有可能会变化的话，你会希望这些
变化不会传播给程序代码的其它部分。这么做不但使程序更容易维护，而且它通常使
程序更容易理解（这将降低成本）。

1. 创建型(creational)模式
    如何创建一个对象。这通常包括分离对象创建的细节，这样你的代码就不依赖于对象
    的类型，而且当加入新的类型的对象时也不必改代码。
1.1 Factory模式
    Factory模式的两个重要的功能：
    1）定义创建对象的接口，封装了对象的创建
    2）使得具体化类的工作延迟到了子类中
    局限于创建一类类（有共同基类）

1.2 Abstract Factory模式
    用于创建一组相关或者相互依赖的对象，关键就是将一组对象的创建封装到一个
    用于创建对象的类（ConcreteFactory）中。
    AbstractFactory模式和Factory模式的区别是初学（使用）设计模式时候的一个容易
    引起困惑的地方。实际上，AbstractFactory模式是为创建一组（有多类）相关或依赖
    的对象提供创建接口，而Factory模式正如我在相应的文档中分析的是为一类对象提供
    创建接口或延迟对象的创建到子类中实现。并且可以看到，AbstractFactory模式通
    常都是使用Factory模式实现（ConcreteFactory1）。
1.3 Singleton模式
    Singleton模式经常和Factory(AbstractFactory)模式一起使用，因为系统中工厂对象
    一般来说只有一个。
1.4 Builder模式
    


2. 结构型(structural)模式
    设计出满足某些工程里特定约束的对象。它的工作原理是这样的：一组对象与其它对象
    相关联，当系统发生变化的时候，这些对象之间的关联关系不变。
2.1 Bridge模式
    使用组合（委托）的方式将抽象和实现彻底地解耦，这样是抽象和实现可以分别独立变化

2.2 Adapter模式
    提供将一个类的接口转化为客户希望的接口

2.3 Decorator模式
    提供了一种给类增加职责的方法，不是通过继承实现，而是通过组合


3. 行为型(Behavioral)模式
    指一个程序里处理一系列特定类型操作的对象。